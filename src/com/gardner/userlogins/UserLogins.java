
 /**
  * This template file was generated by dynaTrace client.
  * The dynaTrace community portal can be found here: http://community.compuwareapm.com/
  * For information how to publish a plugin please visit http://community.compuwareapm.com/plugins/contribute/
  **/ 

package com.gardner.userlogins;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.LineNumberReader;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import com.dynatrace.diagnostics.pdk.Monitor;
import com.dynatrace.diagnostics.pdk.MonitorEnvironment;
import com.dynatrace.diagnostics.pdk.MonitorMeasure;
import com.dynatrace.diagnostics.pdk.Plugin;
import com.dynatrace.diagnostics.pdk.Status;
import com.dynatrace.diagnostics.pdk.TaskEnvironment;

/*
 * v1.0.1
 * - Improved error logging
 * - Improved filename checking
 *   Check whether input string ends with server.0.0.log.
 *   Warn if not
 *   
 * TODO - Improve failure failover
 * Persist first execution flag & previous line number to seperate text file
 * then try to recover from plugin execution failures
 */
public class UserLogins implements Monitor
{

	private static final Logger log = Logger.getLogger(UserLogins.class.getName());

	private static String SERVER_PATH = "";
	private boolean m_bFirstExecution = true;
	private int m_iPreviousLastLine = 0; // Holds a running counter of the previous run last line.
	/*
	 * Dynatrace log files list logins / login attempts with the [ClientSessionInitializer] tag
	 * Only interested in thise log lines
	 */
	private static String LINE_FILTER = "[ClientSessionInitializer]";
	private static String USER_TARGET = "userid";
	
	private static final String SERVER_LOG_PATH_PARAM = "serverLogPath";
	private static final String METRIC_GROUP_NAME = "Logins";
	private static final String SUCCESSFUL_LOGINS_MEASURE_NAME = "Successful Logins";
	private static final String UNSUCCESSFUL_LOGINS_MEASURE_NAME = "Failed Logins";
	private static final String SUCCESSFUL_LOG_FILE_LINE_LOOKUP = "successfully";
	private static final String UNSUCCESSFUL_LOG_FILE_LINE_LOOKUP = "Failed";

	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this
	 * scheduled Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link Plugin#teardown() teardown()} will be called
	 * next.
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * @param env
	 *            the configured <tt>MonitorEnvironment</tt> for this Plugin;
	 *            contains subscribed measures, but <b>measurements will be
	 *            discarded</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
		// Config Strings
		String strServerPath = env.getConfigString(SERVER_LOG_PATH_PARAM);
				
		if (strServerPath.isEmpty())
		{
			// DT not holding defaults?
			/*
			 * Potential for bugs here if NOT using DT 6.1
			 */
			strServerPath = "C:/Program Files/Dynatrace/dynaTrace 6.1.0/log/server/Server.0.0.log";
			
			log.severe("Missing path to Server.0.0.log. Defaulting to windows x64 dynatrace 6.1. Please check monitor configuration. Please contact adam.gardner@dynatrace.com with this error.");
		}
		//
		
		// Store persistently
		SERVER_PATH = strServerPath;
		
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Monitor Plugin to retrieve subscribed measures and store
	 * measurements.
	 *
	 * <p>
	 * This method is called at the scheduled intervals. If the Plugin execution
	 * takes longer than the schedule interval, subsequent calls to
	 * {@link #execute(MonitorEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 *
	 * @param env
	 *            a <tt>MonitorEnvironment</tt> object that contains the
	 *            Plugin configuration and subscribed measures. These
	*            <tt>MonitorMeasure</tt>s can be used to store measurements.
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status execute(MonitorEnvironment env) throws Exception
	{
		/*
		 * Check whether SERVER_PATH actually points to the server log file.
		 * Warn if not.
		 */
		if (!SERVER_PATH.endsWith("Server.0.0.log") && !SERVER_PATH.endsWith("server.0.0.log"))
		{
			log.warning("Plugin misconfigured. Are you sure you've set the log file configuration string to point at the Server.0.0.log file?");
		}
		
		parseFile(SERVER_PATH, env);
		
		// We've completed the first run, let's make note of that.
		m_bFirstExecution = false;
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 *
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and
	 * <tt>teardown</tt> are called on different threads, but they are called
	 * sequentially. This means that the execution of these methods does not
	 * overlap, they are executed one after the other.
	 *
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt>
	 * ends -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout,
	 * <tt>execute</tt> stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is
	 * removed -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 *
	 *
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 *
	 * @see Monitor#setup(MonitorEnvironment)
	 */	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		// TODO
	}
	 
	 /***********************
	  *  PRIVATE METHODS
	  ***********************/
	 
	 private MonitorMeasure getMeasure(MonitorEnvironment env, String strInput)
	 {
		 Collection<MonitorMeasure> oMeasures = env.getMonitorMeasures(METRIC_GROUP_NAME, strInput);
		 MonitorMeasure oReturnMeasure = null;
		
		// Should only be one
		for (MonitorMeasure oMeasure : oMeasures)
		{
			oReturnMeasure = oMeasure;
		}
		return oReturnMeasure;
	 }
	 
	 private void parseFile(String strFileToParse, MonitorEnvironment env)
	 {
		LineNumberReader oLineNumberReader = null;
		
		MonitorMeasure oSuccessfulLoginMeasure = getMeasure(env, SUCCESSFUL_LOGINS_MEASURE_NAME);
		MonitorMeasure oFailedLoginMeasure = getMeasure(env, UNSUCCESSFUL_LOGINS_MEASURE_NAME);
		
		try
		{
			File oFile = new File(strFileToParse);
			if (!oFile.exists())
			{
				log.severe("Log file does not exist. Please check the configuration string in the monitor configuration settings.");
			}
			else if (oFile.isDirectory())
			{
				log.severe("Log file is invalid. You've selected a directory. Please check the configuration string in the monitor configuration settings.");
			}
			oLineNumberReader = new LineNumberReader(new FileReader(oFile));
			
			String strLine = null;
			Map<String, Integer> oSuccessfulLoginMap = new HashMap<String,Integer>();
			Map<String, Integer> oFailedLoginMap = new HashMap<String,Integer>();
			while ((strLine = oLineNumberReader.readLine()) != null)
			{
				// If it's a line we're not interested in, skip quickly.
				if (!strLine.contains(LINE_FILTER)) continue;
				
				/* 
				 * Only do the main bulk of the work if we're NOT on a first run
				 * and we're past the previously processed line
				 */				
				if (!m_bFirstExecution && oLineNumberReader.getLineNumber() > m_iPreviousLastLine)
				{
					String strLineUsername = extractUserID(strLine);
					if (strLine.contains(SUCCESSFUL_LOG_FILE_LINE_LOOKUP))
					{
						oSuccessfulLoginMap = modifyMap(oSuccessfulLoginMap,strLineUsername);
					}
					if (strLine.contains(UNSUCCESSFUL_LOG_FILE_LINE_LOOKUP))
					{
						oFailedLoginMap = modifyMap(oFailedLoginMap,strLineUsername);
					}
				}
			}
			
			// Process successful login map
			for (String strUsername: oSuccessfulLoginMap.keySet())
			{
				int iLoginCount = oSuccessfulLoginMap.get(strUsername);

				MonitorMeasure oUniqueUserMeasure = env.createDynamicMeasure(oSuccessfulLoginMeasure, "Successful Logins", strUsername);
				oUniqueUserMeasure.setValue(iLoginCount);
			}
			
			// Process failed login map
			for (String strUsername: oFailedLoginMap.keySet())
			{
				int iLoginCount = oFailedLoginMap.get(strUsername);
				MonitorMeasure oUniqueUserMeasure = env.createDynamicMeasure(oFailedLoginMeasure, "Failed Logins", strUsername);
				oUniqueUserMeasure.setValue(iLoginCount);
			}
			
		}
		catch (Exception e)
		{
			log.warning("Exception caught parsing server log: " + e.getMessage());
			log.warning("For help, please email adam.gardner@dynatrace.com");
			e.printStackTrace();
		}
		finally
		{
			// Store last line	
			try
			{
				m_iPreviousLastLine = oLineNumberReader.getLineNumber();
			}
			catch (Exception e)
			{
				log.severe("Caught Exception setting previous last line.");
			}
			// Close reader
			try
			{
				oLineNumberReader.close();
			}
			catch (IOException e)
			{
				log.info("Exception caught closing reader. Perhaps it was already closed?");
				e.printStackTrace();
			}
		}
	}
	 
	 private Map<String,Integer> modifyMap(Map<String,Integer> oLoginMap, String strUsername)
	 {
		 /*
		  * If this get is null, we haven't seen the user
		  * before. Add with a login count of 1
		  */
		 if (oLoginMap.get(strUsername) == null)
		 {
			 oLoginMap.put(strUsername,1);
		 }
		 else // We have seen the user before, increment the login count
		 {
			 oLoginMap.put(strUsername, oLoginMap.get(strUsername)+1);
		 }
		 return oLoginMap;
	 }
	 
	 private String extractUserID(String strLine)
	 {
		 // User 'xxxx' logged in
		 int iStartIndex = strLine.indexOf("'")+1;

		 String strUserID = strLine.substring(iStartIndex, strLine.indexOf('\'', iStartIndex));
		 
		 // User ID is now xxxx
		 return strUserID;
	}
}
